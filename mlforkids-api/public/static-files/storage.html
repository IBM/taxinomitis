<!DOCTYPE html>
<html>
    <script type="text/javascript">
        let projectsDbHandle;
        const PROJECTS_DB_NAME = 'mlforkidsLocalProjects';
        const PROJECTS_TABLE = 'projects';

        const trainingDataDatabases = {};
        const TRAINING_DB_NAME_PREFIX = 'mlforkidsProject';
        const TRAINING_TABLE = 'training';


        //-----------------------------------------------------------
        //  common functions
        //-----------------------------------------------------------

        function promisifyIndexedDbRequest (request) {
            return new Promise(function (resolve, reject) {
                request.onsuccess = resolve;
                request.onerror = reject;
            });
        }


        function noop() {}


        function initProjectsDatabase (event) {
            console.log('[ml4kstorage] initProjectsDatabase');
            event.target.result.createObjectStore(PROJECTS_TABLE, { keyPath: 'id', autoIncrement: true });
        }
        function initTrainingDatabase (event) {
            console.log('[ml4kstorage] initTrainingDatabase');
            const table = event.target.result.createObjectStore(TRAINING_TABLE, { keyPath: 'id', autoIncrement: true });
            table.createIndex('label', 'label', { unique: false });
        }


        function getProjectsDatabase() {
            console.log('[ml4kstorage] getProjectsDatabase');

            const request = window.indexedDB.open(PROJECTS_DB_NAME);
            request.onupgradeneeded = initProjectsDatabase;

            return promisifyIndexedDbRequest(request)
                .then(function (event) {
                    return event.target.result;
                });
        }
        function getTrainingDatabase(projectId) {
            console.log('[ml4kstorage] getTrainingDatabase');

            const request = window.indexedDB.open(TRAINING_DB_NAME_PREFIX + projectId);
            request.onupgradeneeded = initTrainingDatabase;

            return promisifyIndexedDbRequest(request)
                .then(function (event) {
                    return event.target.result;
                });
        }


        async function requiresProjectsDatabase() {
            if (!projectsDbHandle) {
                projectsDbHandle = await getProjectsDatabase();
            }
        }
        async function requiresTrainingDatabase(projectId) {
            if (!trainingDataDatabases[projectId]) {
                trainingDataDatabases[projectId] = await getTrainingDatabase(projectId);
            }
        }


        function requiresResult(event) {
            if (event &&
                event.target &&
                event.target.result)
            {
                return event.target.result;
            }

            const notFoundErr = new Error('not found');
            notFoundErr.status = 404;
            notFoundErr.data = {
                error: 'not found'
            };
            throw notFoundErr;
        }

        function requiresIntegerId(id) {
            return parseInt(id, 10);
        }


        //-----------------------------------------------------------
        //  PROJECTS database
        //-----------------------------------------------------------

        async function getProject(projectId) {
            console.log('[ml4kstorage] getProject', projectId);

            await requiresProjectsDatabase();

            const transaction = projectsDbHandle.transaction([ PROJECTS_TABLE ], 'readonly');
            const request = transaction.objectStore(PROJECTS_TABLE).get(requiresIntegerId(projectId));

            return promisifyIndexedDbRequest(request)
                .then(function (event) {
                    return requiresResult(event);
                });
        }



        //-----------------------------------------------------------
        //  TRAINING DATA store
        //-----------------------------------------------------------

        async function getTrainingData(projectId) {
            console.log('[ml4kstorage] getTrainingData', projectId);

            await requiresTrainingDatabase(projectId);

            const transaction = trainingDataDatabases[projectId].transaction([ TRAINING_TABLE ], 'readonly');
            const request = transaction.objectStore(TRAINING_TABLE).getAll();

            return promisifyIndexedDbRequest(request)
                .then(function (event) {
                    return event.target.result;
                });
        }


        async function getTrainingDataItem(projectId, trainingDataId) {
            console.log('[ml4kstorage] getTrainingDataItem');

            await requiresTrainingDatabase(projectId);

            const transaction = trainingDataDatabases[projectId].transaction([ TRAINING_TABLE ], 'readonly');
            const request = transaction.objectStore(TRAINING_TABLE).get(requiresIntegerId(trainingDataId));

            return promisifyIndexedDbRequest(request)
                .then(function (event) {
                    return requiresResult(event);
                });
        }


        async function addTrainingData(projectId, trainingObject) {
            console.log('[ml4kstorage] addTrainingData');

            await requiresTrainingDatabase(projectId);

            const transaction = trainingDataDatabases[projectId].transaction([ TRAINING_TABLE ], 'readwrite');
            const request = transaction.objectStore(TRAINING_TABLE).add(trainingObject);

            return promisifyIndexedDbRequest(request)
                .then(function (event) {
                    trainingObject.id = event.target.result;

                    addLabel(projectId, trainingObject.label);

                    return trainingObject;
                });
        }


        async function addLabel(projectId, newlabel) {
            console.log('[ml4kstorage] addLabel');

            await requiresProjectsDatabase();

            const transaction = projectsDbHandle.transaction([ PROJECTS_TABLE ], 'readwrite');
            const projectsTable = transaction.objectStore(PROJECTS_TABLE);
            const readRequest = projectsTable.get(requiresIntegerId(projectId));
            const readEvent = await promisifyIndexedDbRequest(readRequest);
            const projectObject = requiresResult(readEvent);

            if (!projectObject.labels.includes(newlabel)) {
                projectObject.labels.push(newlabel);

                const updateRequest = projectsTable.put(projectObject);
                await promisifyIndexedDbRequest(updateRequest);
            }
        }


        async function getLabelCounts(projectId) {
            console.log('[ml4kstorage] getLabelCounts', projectId);

            return Promise.all([
                getProject(projectId),
                getTrainingData(projectId)
            ])
            .then(function (projectdata) {
                const project = projectdata[0];
                const labels = {};
                for (const label of project.labels) {
                    labels[label] = 0;
                }

                const trainingdata = projectdata[1];
                for (const trainingitem of trainingdata) {
                    labels[trainingitem.label] += 1;
                }

                return labels;
            });
        }


        async function getTrainingDataByLabel(projectId, label) {
            console.log('[ml4kstorage] getTrainingDataByLabel');

            await requiresTrainingDatabase(projectId);

            const trainingTransaction = trainingDataDatabases[projectId].transaction([ TRAINING_TABLE ], 'readonly');
            const trainingTable = trainingTransaction.objectStore(TRAINING_TABLE);

            return new Promise(function (resolve, reject) {
                const trainingItems = [];
                trainingTable.index('label').openCursor(IDBKeyRange.only(label)).onsuccess = function (event) {
                    const cursor = event.target.result;
                    if (cursor) {
                        trainingItems.push(cursor.value);
                        cursor.continue();
                    }
                    else {
                        resolve(trainingItems);
                    }
                };
            });
        }



        //-----------------------------------------------------------
        //  exposing public functions for use by iframe hosts
        //-----------------------------------------------------------

        const mlforkidsDataFunctions = {
            getProject,
            getTrainingData,
            getTrainingDataItem,
            addTrainingData,
            getLabelCounts,
            getTrainingDataByLabel
        };

        const ALLOWED_ORIGINS = [
            'https://scratch.machinelearningforkids.co.uk',
            'https://machinelearningforkids.co.uk',

            // 'http://ml-for-kids-local.net:3000',
            // 'http://ml-for-kids-local.net:9000',
            // 'http://localhost:3000',
            // 'http://localhost:9000'
        ];
        window.addEventListener('message', function (event) {
            if (!ALLOWED_ORIGINS.includes(event.origin)) {
                return;
            }
            if (event.data.fn in mlforkidsDataFunctions) {
                mlforkidsDataFunctions[event.data.fn](...event.data.args)
                    .then(function (output) {
                        const response = {
                            output : output ? output : {},
                            correlId: event.data.correlId
                        };
                        event.source.postMessage(response, event.origin);
                    })
                    .catch(function (err) {
                        const response = {
                            err,
                            correlId: event.data.correlId
                        };
                        event.source.postMessage(response, event.origin);
                    });
            }
            else if (event.data.fn === 'registerForModelStorageUpdates') {
                window.addEventListener('storage', (evt) => {
                    if (evt.key === event.data.args[0]) {
                        event.source.postMessage({
                            output: evt.key,
                            correlId: event.data.correlId
                        }, event.origin);
                    }
                });
            }
            else {
                console.error('[mlforkids storage] unsupported function call');
            }
        });
    </script>
</html>